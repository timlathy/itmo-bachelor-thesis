\documentclass[a4paper,14pt]{extarticle}
\usepackage{fontspec, unicode-math}
\usepackage[english, russian]{babel}
\setmainfont{Times New Roman}
\setmonofont{CMU Typewriter Text}

\usepackage{enumitem}
\usepackage{alltt}

\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\captionsetup[figure]{name={Рисунок}}

% === WIP ===

\usepackage{xcolor}
\newcommand{\todo}[1]{\textbf{\textcolor{red}{#1}}}

% === Formatting ===
% Based on https://github.com/3ap/ifmo-vkr-preamble

\usepackage[top=20mm, bottom=20mm, left=25mm, right=10mm]{geometry}

\usepackage[nodisplayskipstretch]{setspace}
\onehalfspacing

\addto\captionsrussian{
  \renewcommand{\contentsname}{Оглавление}
}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage{titlesec}
\titleformat{\section}[block]{\centering\bfseries\large}{\arabic{section}}{1ex}{\MakeUppercase}
\titleformat{\subsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}}{1ex}{}
\titleformat{\subsubsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}{1ex}{}
\titlespacing*{\section}{0pt}{42pt}{42pt}

% Avoid overfull boxes by stretching word spacing
\setlength\emergencystretch{\hsize}

% === Bibliography ===

\usepackage[parentracker=true,
  backend=biber,
  language=russian,
  autolang=other,
  sorting=none,
  citestyle=gost-numeric,
  bibstyle=gost-numeric,
]{biblatex}
\addbibresource{thesis.bib}

\usepackage{xurl}
\usepackage[hidelinks]{hyperref}

% === Commands ===

\newcommand{\topic}[1]{\textbf{#1.}}

\newenvironment{ul}{\begin{itemize}[noitemsep,topsep=0em]}{\end{itemize}\vspace{20pt}}

\newenvironment{ol}{\begin{enumerate}[noitemsep,topsep=0em]}{\end{enumerate}\vspace{20pt}}

\newenvironment{inlineul}{\begin{itemize}[noitemsep,topsep=0em]}{\end{itemize}}

\newenvironment{inlineol}{\begin{enumerate}[noitemsep,topsep=0em]}{\end{enumerate}}

% === Body ===

\begin{document}

\tableofcontents
\newpage

\section*{ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ}
\phantomsection\addcontentsline{toc}{section}{ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ}

\textit{Шейдер} — программа, предназначенная для исполнения на графическом процессоре.

\newpage

\section*{ВВЕДЕНИЕ}
\phantomsection\addcontentsline{toc}{section}{ВВЕДЕНИЕ}

\topic{Актуальность темы исследования} Графические процессоры широко используются
для математических расчетов, в частности, в машинном обучении. Для достижения оптимальной
утилизации аппаратных ресурсов алгоритмы реализуются при помощи ассемблера. Отсутствие
средств верификации ассемблерных программ для ГП затрудняет разработку и
может привести к некорректным результатам во время исполнения.

Особый интерес представляют графические процессоры AMD, которые предоставляют разработчику
на ассемблере доступ к аппаратному набору команд. В связи с особенностями аппаратной
реализации от программиста требуется ручное разрешение зависимостей по данным
путем вставки специальных инструкций.

Ошибки в разрешении зависимостей могут быть обнаружены методами статического анализа
еще на этапе разработки программы. Задача осложняется тем, что при разработке
на ассемблере используются различные препроцессоры и трансляторы кода. В работе
предлагается анализ исполняемых файлов, который позволяет работать с единым
представлением программы, которое не зависит от инструментов, используемых при разработки.\\

\topic{Степень теоретической разработанности темы} Статический анализ исполняемых файлов
широко рассмотрен в работах, посвященных информационной безопасности, а именно:
дизассемблированию обфусцированного кода и обнаружению вирусов,
проверке недоверенного кода в плагинах на некорректный доступ к памяти и т.д.\cite{static-analysis-binary}

Существующие средства статического анализа для графических процессоров работают с
высокоуровневыми языками (CUDA, OpenCL) и направлены на обнаружение состояний
гонки (\textit{data races}), при которых несколько потоков записывают
и читают одни и те же данные в памяти без синхронизации, т.е. ошибки, которые
не отслеживаются компилятором\cite{gpu-static-verification}.

Cочетание статического анализа исполняемых файлов и программ для графических
процессоров широко не рассматривается, поскольку разработка ассемблерных программ,
оптимизированных для конкретных ГП, менее распространена и зачастую выполняется
проприетарно.\\

\textbf{Целью работы} является снижение трудозатрат на разработку ассемблерных шейдеров
путем создания средства статического анализа исполняемых файлов для графических процессоров.\\

\textbf{Задачи:}
\begin{ul}
\item Изучение архитектурных особенностей графических процессоров AMD с целью выделения
круга задач, решаемых статическим анализом.
\item Исследование открытых средств статического анализа исходного кода, в особенности
компиляторов, для ознакомления с современными подходами (алгоритмами).
\item Разработка программного средства статического анализа исполняемых файлов
на основании проведенного исследования.
\item Тестирование работоспособности системы на существующих ассемблерных шейдерах
с намеренно внесенными ошибками.
\end{ul}

\textbf{Объектом исследования} в работе выступают методы статического анализа кода
в применении к исполняемым файлам для графических процессоров.\\

\textbf{Практическая значимость:} \todo{...}

\newpage
\section{Обзор предметной области}

\subsection{Неспециализированные вычисления на графических процессорах}

Графические процессоры широко применяются для неспециализированных вычислений —
\textit{general-purpose computing on graphics processing units, GPGPU}.
Особый интерес представляют математические расчеты, используемые в
\textit{сверточных нейронных сетях} — методе машинного обучения, в основе которого
лежат матричные операции свертки, субдискретизации (\textit{pooling}) и т.п.
Производительность графических ускорителей в выполнении подобных операций
значительно превышает производительность центральных процессоров.

Для исполнения неспециализированных вычислений требуются специальные платформы,
которые выполняют несколько задач:
\begin{ul}
\item Преобразование исходных текстов на определенном языке программирования
  в исполняемый файл, содержащий инструкции для графического процессора и метаданные о программе.
\item Предоставление библиотек математических примитивов (BLAS, FFT)
  для использования в вычислительных шейдерах.
\item Предоставление набора интерфейсов для запуска программ на ГП, перемещения данных между
  оперативной памятью и выделенной памятью ускорителя, выполнения других операций.
\item Обеспечение взаимодействия между драйвером ускорителя и пользовательской программой,
  использующей интерфейсы платформы.
\end{ul}

Компания NVIDIA предоставляет для своих ускорителей платформу \textit{CUDA}. Прямым аналогом
со стороны AMD является \textit{ROCm}. Вычислительные шейдеры могут составляться как
на высокоуровневых языках (C++11, OpenCL), так и на ассемблере. Платформа доступна
только на операционной системе Linux.

\subsection{Исполнение шейдеров на графических процессорах}

Графические процессоры достигают высокой производительности в математических операциях
за счет реализации модели выполнения \textit{SIMT} (одиночный поток команд, множество потоков).
Программа разделяется на множество потоков исполнения (\textit{workitems}),
каждый из которых может следовать произвольному пути в программе.

В графических процессорах AMD\footnote{Здесь и далее при обсуждении графических процессоров AMD
подразумеваются архитектуры GCN и CDNA, которые используются в ускорителях для высокопроизводительных
вычислений и машинного обучения. Современные ГП общего назначения строятся на базе архитектуры RDNA,
которая обладает рядом отличий: возможностью исполнения 32 потоков, разделенным счетчиком векторных
операций с памятью и т.д.}
одна и та же инструкция в программе исполняется одновременно на наборе из 64 потоков,
именуемом \textit{wavefront}. Инструкции делятся на два вида: векторные и скалярные.
Векторные операции применяются к значениям в каждом потоке за счет использования SIMD АЛУ.
Скалярные операции применяются к одному значению на весь набор потоков.

Рабочие данные хранятся в скалярных, \textit{SGPR}, и векторных, \textit{VGPR},
32-разрядных регистрах общего назначения. Программа может использовать до 102
SGPR (\texttt{s0} — \texttt{s101}) и до 256 VGPR ({\texttt{v0} — \texttt{v255}).

\subsubsection{Управление потоком выполнения программы}
\label{section:gcn-program-flow}

Ветвление в шейдерах осуществляется двумя способами: изменением счетчика команд скалярными
инструкциями и маскированием потоков векторными инструкциями сравнения\cite{vega-isa}.
Маскирование заключается в изменении маски активности (\textit{EXEC}), каждый бит которой
соотвествует отдельному потоку. Для потоков с нулевым битом векторные операции интерпретируются как NOP.
Если все биты в маске активности равны нулю, векторные инструкции не пропускаются.

Скалярные инструкции ветвления разделяются на несколько видов:
\begin{ul}
\item Команды прямого перехода, в которых кодируется целевой адрес как смещение относительно счетчика команд:
  \begin{inlineul}
  \item безусловный переход (\texttt{s\_branch});
  \item условный переход (\texttt{s\_cbranch\_*});
  \item вызов функции (\texttt{s\_call\_b64}): перед переходом значение счетчика команд
  сохраняется в паре регистров общего назначения.
  \end{inlineul}
\item Команды косвенного перехода, которые считывают целевой адрес из пары регистров общего назначения:
  \begin{inlineul}
  \item безусловный переход (\texttt{s\_setpc\_b64});
  \item вызов функции (\texttt{s\_swappc\_b64}).
  \end{inlineul}
\item Команды прямого (\texttt{s\_cbranch\_i\_fork}) и косвенного (\texttt{s\_cbranch\_g\_fork})
  условного перехода по маске. Переход по адресу осуществляется только для потоков, которые соответствует
  маски-операнду; адрес следующей инструкции и инверсия маски-операнда сохраняются в стек
  (в качестве стека используются регистры общего назначения, по 4 регистра на один переход).
  Команда \texttt{s\_cbranch\_join} размещается в конце блока, в пределах которого осуществляется ветвление.
  Она снимает со стека адрес следующего перехода и соответсвующую маску активности и применяет их.
\item Команда переключения режима пропуска векторных инструкций \texttt{s\_setvskip}. В режиме
  \texttt{VSKIP} все векторные инструкциии пропускаются; векторные операции с памятью не выполняются
  и не инкрементируют счетчики незавершенных операций.
\end{ul}

\subsubsection{Ожидание готовности данных при запросах к памяти}
\label{section:gcn-waitcnt}

Как и в центральных процессорах, время доступа к памяти в графических ускорителях
значительно превышает время выполнения арифметико-логических инструкций.
Для сокращения простоя в современных ЦП используется внеочередное исполнение, при котором
инструкции выполняются не в порядке следования в программе, а в порядке доступности операндов.
В ГП для скрытия задержки используется иной механизм: при ожидании данных одним набором
потоков исполнение переходит к следующему.
% http://developer.amd.com/wordpress/media/2012/10/GCN-Performance-FTW-Stephan-Hodes.ppsx

Тем не менее, количество наборов потоков, между которыми передается управление, ограничено
аппаратными ресурсами — в частности, объемом регистрового файла для хранения состояния каждого
исполняемого набора. В связи с этим операции с памятью в архитектуре ГП AMD асинхронны.
После запроса на чтение или запись программист может вставить несвязанные инструкции,
сократив время простоя АЛУ. Требование готовности данных обозначается специальной
инструкцией \texttt{s\_waitcnt}, <<ожидание значения счетчика>>.

Предусмотрено три счетчика операций:
\begin{ul}
\item \texttt{vmcnt} для векторных операций с глобальной памятью;
\item \texttt{lgkmcnt} для скалярных операций с глобальной памятью и векторных операций с локальной памятью;
\item \texttt{expcnt} для векторных операций записи в общую память.
\end{ul}

После каждой операции с памятью соответствующий счетчик инкрементируется, а по завершении
операции — декрементируется. Операции одного типа завершаются в порядке очереди, что
позволяет ожидать готовности только тех данных, которые необходимы для вычислений в данный
момент. Если же счетчик содержит операции различных типов, или какая-либо из операций
характеризуется внеочередным завершением (скалярный доступ к памяти), то очередность не гарантируется.
В таком случае программист должен ожидать обуления соответствующего счетчика.

Инструкция ожидания \texttt{s\_waitcnt} кодирует значение счетчика, до достижения
которого исполнение программмы приостанавливается. В инструкции выделено 6 бит под значение
\texttt{vmcnt}, 3 бита под значение \texttt{expcnt}, 4 бита под значение \texttt{lgkmcnt}.
Если все биты счетчика выставлены в 1, то его значение не ожидается. Таким образом,
выражение ожидания может содержать разные значения для одного или нескольких счетчиков,
например: \texttt{s\_waitcnt vmcnt(1) lgkmcnt(2)}. Команду
\texttt{s\_waitcnt vmcnt(0) lgkmcnt(0) expcnt(0)}, которая соответствует ожиданию всех
незавершенных операций, принято сокращать как \texttt{s\_waitcnt 0}.

\subsubsection{Разрешение конфликтов по данным}

Существует также ряд зависимостей по данным, не связанных с доступом к памяти,
которые не отслеживаются графическим процессором из-за особенностей аппаратной реализации.
В таких случаях программист должен вручную обеспечить необходимое количество независимых
инструкций между зависимыми операциями. В официальном руководстве к архитектуре GCN
таких ситуаций определено 16\cite{vega-isa}. Архитектура CDNA, на которой основывается передовой ускоритель
вычислений MI100, добавляет к этому 21 ситуацию, относящуюся к матричным операциям\cite{cdna-isa}.

\subsection{Разрешение зависимостей при компиляции шейдеров}

При использовании высокоуровневых языков программисту не требуется следить
за ожиданием обращений к памяти и предотвращать конфликты по данным;
эту задачу берет на себя компилятор. Перед изучением используемых алгоритмов
разрешения зависимостей рассмотрим общий принцип работы современных компиляторов.

Поддержка различных языков программирования и целевых платформ осуществляется
путем выделения независимых фаз компиляции, которые реализуются отдельными модулями.
Выделяют три основных модуля\cite[Глава~1]{compilers}:

\begin{ul}
\item \textit{фронтэнд} (\textit{frontend}), отвечающий за трансляцию исходного текста программы в
  \textit{промежуточное представление};
\item \textit{оптимизатор} (\textit{optimizer}), выполняющий различные преобразования над промежуточным
  представлением, которые направлены на сокращение времени исполнения,
  уменьшение размера программы и т.д.;
\item \textit{бэкэнд} (\textit{backend}), преобразующий промежуточное представление в машинный код.
\end{ul}

Помимо промежуточного представления программы, которое передается между фазами,
модуль может использовать внутренние представления, необходимые для выполнения его функций.
Например, при чтении исходного кода программы фронтэнд создает синтаксические деревья,
а при генерации машинного кода бэкэнд работает с различными графами, моделирующими поведение
программы.

Интересующая нас задача вставки инструкций \texttt{s\_waitcnt} и \texttt{s\_nop} входит
в диспетчеризацию инструкций, которая производится бэкэндом над представлением программы
в виде \textit{управляющего графа} (\textit{control flow graph}).

Управляющий граф\cite{cfg-allen}\cite{cfg-ru} представляет собой ориентированный граф, вершинами которого
выступают \textit{базовые блоки} (\textit{basic blocks}) — последовательности инструкций,
не содержащие переходов в другие места программы, за исключением последней
инструкции в блоке, \textit{точки выхода}. Ребра отражают переходы в программе.
В задачах анализа важны следующие взаимосвязи вершин:
\begin{inlineul}
\item \textit{потомок вершины $p$} (\textit{successor of $p$}) — такая вершина $q$,
  для которой в орграфе существует путь из $p$ в $q$;
\item \textit{предок вершины $p$} (\textit{predecessor of $p$}) — такая вершина $q$,
  для которой в орграфе существует путь из $q$ в $p$.
\end{inlineul}
Стоит отметить, что одна и та же вершина $q$ может быть как потомком, так и предком вершины $p$,
что отражает циклическую конструкцию в программе.

Основным методом решения задач статического анализа являются итеративный подход\cite[Глава~8]{compilers}.
Каждой вершине присваивается изначальное состояние. В процессе обхода графа к каждой вершине
применяется функция, преобразующая ее текущее состояние в новое. Полученное состояние
соединяется с состоянием последующих вершин в направлении обхода, образуя их новые состояния.
Обход продолжается до тех пор, пока не будет достигнута неподвижная точка (\textit{fixed point}), т.е.
пока состояния вершин не перестанут изменяться. Конечность алгоритма анализа может гарантироваться
при условии, что домен состояний является конечным множеством, а изменение состояний происходит монотонно.

Порядок обхода графа выбирается в зависимости от решаемой задачи:
\begin{ul}
\item Анализ прямого потока данных (\textit{forward dataflow}), к которому относится отслеживание обращений
  к памяти, производится при помощи прямого обхода в глубину (\textit{preorder}; посещается блок, затем его потомки) или RPO-обхода (\textit{reverse postorder}; блок посещается после всех предков, за исключением предков, которые связаны с блоком обратными ребрами).

\item Анализ обратного потока данных (\textit{backward dataflow}), к которому относится проверка вставки
слотов задержки перед использованием зависимых данных, производится при помощи обратного обхода
(\textit{postorder}; посещается блок, затем его предки).
\end{ul}

В платформе ROCm для всех поддерживаемых высокоуровневых языков программирования (С++, OpenCL)
используется единый компилятор шейдеров — \textit{Clang}, часть проекта LLVM.
Компилятор обладает модульным смотрением, описаным выше.

За генерацию машинного кода для графических процессоров AMD отвечает бэкэнд AMDGPU.
Рассмотрим подробнее его работу в LLVM версии 12\cite{llvm-12}.

\subsubsection{Обработка запросов к памяти в компиляторе LLVM}
\label{section:gcn-waitcnt-llvm}

Вставка инструкций \texttt{s\_waitcnt} производится классом \texttt{SIInsertWaitcnts}.
Он наследуется от \texttt{MachineFunctionPass}, то есть является проходом LLVM,
который выполняется во время генерации кода над инструкциями в каждой функции программы.

\texttt{SIInsertWaitcnts} реализует итеративный алгоритм анализа прямого потока данных.
Обход управляющего графа осуществляется в RPO-порядке.

Каждому из блоков присваивается объект \texttt{WaitcntBrackets}, отслеживающий:
\begin{ul}
\item число всех обращений к памяти для каждого из счетчиков операций
  (\texttt{vmcnt}, \texttt{lgkmcnt}, \texttt{expcnt}) — $ScoreUb$;
\item число завершенных операций для каждого из счетчиков (согласно
  вставленным инструкциям \texttt{s\_waitcnt}) — $ScoreLb$;
\item номер последней операции, использующей регистр, для всех регистров
  в программе (отсутствию операций соответствует значение $0$) — $VgprScores$, $SgprScores$.
\end{ul}

Функция обновления состояния блока посещает каждую инструкцию в блоке в порядке
исполнения. При этом выполняется следующая последовательность действий:
\begin{ol}
\item Проверяются случаи, в которых необходимо добавить выражение ожидания:
  \begin{ol}
  \item при выходе из функции (\texttt{s\_setpc\_b64}) ожидаются все операции;
  \item если операнд инструкции является скалярным регистром $s$, который используется в
    незавершенной операции, т.е. выполняется $SgprScores[s] > ScoreLb[lgkmcnt]$:
    \begin{inlineol}
    \item при наличии незавершенных операций \texttt{flat} согласно архитектуре набора
      команд\cite[Глава~9.2.2]{vega-isa} вставляется \texttt{s\_waitcnt 0};
    \item иначе вставляется \texttt{s\_waitcnt lgkmcnt(0)}, поскольку скалярные операции с памятью
      выполняются вне очереди;
    \end{inlineol}
  \item если операнд инструкции является векторным регистром $v$, который используется в
    незавершенной операции, т.е. выполняется $VgprScores[vmcnt][v] > ScoreLb[vmcnt]$ или
    $VgprScores[lgkmcnt][v] > ScoreLb[lgkmcnt]$:
    \begin{inlineol}
    \item при наличии незавершенных операций \texttt{flat} согласно архитектуре набора
      команд вставляется \texttt{s\_waitcnt 0};
    \item если операция входит в счетчик \texttt{vmcnt}, то вставляется \texttt{s\_waitcnt vmcnt(w)},
      где $w = ScoreUb[vmcnt] - VgprScores[vmcnt][v]$;
    \item если операция входит в счетчик \texttt{lgkmcnt} и имеет тот же тип, что и все
      незавершенные операции в счетчике, то вставляется \texttt{s\_waitcnt vmcnt(w)},
      где $w = ScoreUb[lgkmcnt] - VgprScores[lgkmcnt][v]$;
    \item иначе вставляется \texttt{s\_waitcnt lgkmcnt(0)}, поскольку скалярные операции с памятью
      выполняются вне очереди.
    \end{inlineol}
  \end{ol}
\item Если необходимо добавить выражение ожидание:
  \begin{inlineol}
  \item при наличии в блоке предшествующей инструкции \texttt{s\_waitcnt} выражение объединяется
    с предшествующей инструкцией, иначе в блок вставляется новая инструкция \texttt{s\_waitcnt};
  \item обновляется число завершенных операций ($ScoreLb$) для счетчиков,
    которые входят в выражение ожидания.
  \end{inlineol}
\item Если рассматриваемая инструкция является обращением к памяти,
  число обращений к памяти ($ScoreUb$) инкрементируется, и полученное значение
  присваивается номеру операции регистра назначения ($VgprScores$ или $SgprScores$).
\end{ol}

Функция соединения, которая обновляет состояния всех потомков рассматриваемого блока,
подсчитывает незавершенные операции в исходном и новом состоянии, и обновляет
счетчики согласно наибольшим значениям, т.е. изменение состояний происходит монотонно.

Исследование принципа работы используемого алгоритма позволяет заключить, что он обладает
следующими ограничениями:
\begin{ul}
\item в некоторых случаях (например, перед возвратом из функции) вставляются слишком
  строгие ожидания, что может привести к ненужному простою АЛУ;
\item отслеживается только числовое значение счетчиков — если существующей инструкции
  \texttt{s\_waitcnt} недостаточно, алгоритм не позволяет определить, какая команда
  совершила неучтенное обращение к памяти.
\end{ul}

\subsubsection{Вставка слотов задержки в компиляторе LLVM}

Разрешение зависимостей со вставкой слотов задержки выполняется в LLVM на этапе
диспетчеризации инструкций. За это отвечают классы, наследуемые от \texttt{ScheduleHazardRecognizer}.
Для каждой инструкции вызывается метод \texttt{getHazardType}, который проверяет наличие
конфликтов. Метод может вернуть три значения:
\begin{ol}
\item \texttt{NoHazard} означает, что инструкция может быть помещена в данном участке программы;
\item \texttt{Hazard} указывает на то, что текущее размещение инструкции приведет к аппаратной
  задержке исполнения (\textit{stall}) — при наличии других инструкций, которые
  могут быть помещены в данный участок, диспетчер выберет их;
\item \texttt{NoopHazard} указывает на то, что инструкция не может быть размещена в данном
  участке — диспетчер должен выбрать другие доступные инструкции или вставить пропуск.
\end{ol}

За обнаружение конфликтов при генерации кода для ГП AMD отвечает класс \texttt{GCNHazardRecognizer}.
Во время диспетчеризации инструкции помечается только двумя значениями — \texttt{NoHazard} при
отсутствии конфликта и \texttt{NoopHazard} при необходимости вставки слотов задержки.

\todo{Добавить список конфликтов в приложение и сделать ссылку. Описать обход предшествующих инструкций.
Упомянуть то, что ассемблерные вставки верифицируются лишь частично \url{https://github.com/llvm/llvm-project/blob/release/12.x/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp\#L778}}

\subsection{Ручное составление ассемблерных шейдеров}

Одной из основных целей создания ассемблерных шейдеров является сокращение
времени простоя вычислительных блоков ускорителя за счет применения ручных оптимизаций,
которые не могут быть реализованы на высокоуровневом языке.

К примеру, при компиляции высокоуровневых языков обработка запросов к памяти сводится ко вставке
инструкций ожидания. Программист на ассемблере, в свою очередь, старается также обеспечить,
чтобы между запросом к памяти и ожиданием счетчика было как можно больше несвязанных
арифметических операций, а ожидаемое значение было как можно более точным, поскольку
это увеличивает долю полезной работы. При этом повышается вероятность совершения
ошибки — пропуска необходимой инструкции из-за сложной структуры программы.

\todo{Сравнить с автоматической обработкой зависимостей}.

Как правило, инструменты статического анализа работают с исходным кодом программ,
поскольку в них сохраняются высокоуровневые конструкции (переменные, циклы, функции).

В ассемблерных программах подобные конструкции реализуются при помощи макросов,
которые не несут в себе полезной для анализа информации, такой как области видимости и пр.
Помимо этого, существует несколько трансляторов ассемблерного кода — GAS, CRLX, проприетарные — которые
различаются набором макросов и синтаксисом инструкций.

В связи с этим в качестве исходных данных в работе рассматриваются исполняемые файлы,
формат которых строго определен.

\subsection{Обоснование применимости статического анализа}

\todo{Разрешение зависимостей уже существует для высокоуровневых языков. Возможно использование алгоритмов, направленных на отслеживание источников проблем. Различные трансляторы ассемблерного кода, необходимо рассматривать исполняемые файлы. Необходимо восстановить CFG.}

\section{Разработка подхода к статическому анализу шейдеров}

\subsection{Постановка задач, решаемых статическим анализом}

В ходе исследования предметной области были выделены две области, в которых ошибку программиста
на ассемблере может быть сложно диагностировать во время исполнения, но можно полностью
предотвратить, внедря статическую верификацию программу:
\begin{ol}
\item \textbf{Вставка слотов задержки (\texttt{s\_nop})}. При нехватке несвязанных инструкций между операциями, которые зависят по данным, необходимо сформировать предупреждение, которое указывает на
на зависимые инструкции, а также содержит количество недостающих слотов задержки.
\item \textbf{Вставка инструкций ожидания (\texttt{s\_waitcnt})}. При обращении к регистрам, содержание которых читается из памяти, без ожидания соответствующего счетчика, необходимо сформировать предупреждение, которое указывает на инструкцию, читающую регистр, и инструкцию, использующую регистр, а также показывает состояние очереди запросов.
\end{ol}

Разрабатываемый подход к анализу программы должен удовлетворять следующим требованиям:

\begin{ul}
\item входными данными выступают исполняемые (объектные) файлы, поскольку представление исходного текста программы может существенно различаться в зависимости от используемого ассемблера;
\item \todo{восстановление управляющего графа?}
\end{ul}

\subsection{Выделение этапов статического анализа}

Для удовлетворения поставленных требований были выделены следующие этапы работы системы:\\

\topic{Извлечение машинного кода и метаданных} Запуск вычислительных шейдеров на платформе AMD
как правило просходит в средах исполнения HSA и HIP. Программы хранятся в файлах ELF,
которые именуются \textit{code objects (CO)}.
Встречается несколько версий файла с различной структурой программы: так,
в \textit{CO V2} метаданные хранятся как часть исполняемой секции \texttt{.text}, а
в \textit{CO V3} они записываются в секцию \texttt{.rodata}.

Хотя в исполняемых файлах могут сохранятся отладочные символы
(имена меток и макросов), в анализе они использоваться не должны, поскольку их наличие не гарантируется.
Символы могут быть намеренно удалены для уменьшения размера исполняемого файла;
некоторые трансляторы ассемблерного кода изначально не поддерживают таблицы символов.

\topic{Дизассемблирование} Преобразование двоичного кода инструкции в ее текстовое представление
требует построения таблиц кодов операций и реализации логики декодирования операндов.
Задача осложняется следующими особенностями архитектуры команд графических процессоров AMD:
\begin{ul}
\item общее число инструкций превышает несколько сотен \todo{ct};
\item размер машинных инструкций варьируется, поэтому для правильного дизассемблирования необходимо
  учесть все существующие инструкции, даже если при анализе достаточно рассмотрения лишь части операций;
\item кодирование машинных инструкций раличается между семействами графических процессоров.
\end{ul}
Проект LLVM содержит официально поддерживаемый дизассемблер, использование которого позволяет
преодолеть обозначенные трудности.

\topic{Восстановление потока управления} Помимо статических команд перехода, в которых напрямую
кодируется адрес следующей инструкции, набор инструкций графических процессоров AMD также содержит
команды динамического перехода, в которых адрес следующей инструкции считывается из регистров
общего назначения.

\todo{...}

\subsection{Составление алгоритма проверки инструкций ожиданий}

В ходе изучения подходов к статическому анализу было установлено, что верификация
вставки инструкций ожидания является проблемой анализа прямого потока данных.
При разработке алгоритма был выбран итеративный подход, аналогично реализации,
используемой в LLVM, рассмотренной в разделе~\ref{section:gcn-waitcnt-llvm}.

В отличие от реализации, используемой в LLVM, алгоритм сохраняет состояние всей очереди
незавершенных обращений. Для каждого из обращений хранится адрес инструкции, которая его
совершает, множество затрагиваемых регистров и тип запроса.

На рисунке~\ref{fig:diagram-waitcnt} приведена блок-схема основного цикла
алгоритма, который отвечает за обход управляющего графа. Для упрощения реализации
вместо RPO-обхода базовых блоков используется прямой обход в глубину.

На рабочий стек (\textit{WorkStack}) помещается базовый блок вместе с состоянием
очереди запросов к памяти на момент входа в него. На основании этой информации
процедурой \textit{AnalyzeInstructions} находится очередь запросов на момент
выхода из блока, которая становится входным состоянием для его потомков.

Помимо этого, каждый блок \textit{BB} ассоциируется с множеством выходных состояний,
для которых был совершен обход потомков (\textit{Visited[BB]}). Если текущее выходное
состояние уже было <<посещено>>, то обход потомков не выполняется.

Однако в случае, когда базовые блоки образуют цикл, содержащий обращения к памяти без ожиданий
готовности данных, рост очереди обращений не ограничен. Чтобы гарантировать конечность
алгоритма, перед добавлением текущего выходного состояния в \textit{Visited[BB]} из него
удаляются дубликаты — обращения, исходящие из одного и того же адреса в программе. Таким образом,
множество выходных состояний монотонно увеличивается и ограничено числом обращений к памяти
во всей программе.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{diagrams/alg-waitcnt}
\caption{Блок-схема основного цикла проверки инструкций ожидания}
\label{fig:diagram-waitcnt}
\end{figure}

Рассмотрим подробнее работу процедуры \textit{AnalyzeInstructions}, блок-схема которой приведена
на рисунке~\ref{fig:diagram-waitcnt-analyze}. Она отвечает не только за нахождение нового состояния
очереди запросов к памяти, но и запись сообщений о найденных нарушениях — использовании результатов
обращений к памяти без соответвующего ожидания.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{diagrams/alg-waitcnt-analyze}
\caption{Блок-схема анализа инструкций ожидания в отдельном блоке}
\label{fig:diagram-waitcnt-analyze}
\end{figure}

Основной анализа выступает цикл, который проходит по всем инструкциям в блоке. Действие, совершаемое
на каждой итерации, зависит от типа рассматриваемой инструкции:

\begin{ul}
\item Инструкции ожидания счетчиков \texttt{s\_waitcnt}: из очереди удаляются
  запросы согласно выражению ожидания (см. раздел~\ref{section:gcn-waitcnt}).
\item Инструкции, содержащие регистровые операнды: для каждого из незавершенных запросов
  в очереди проверяется, есть ли среди регистровых операндов в инструкции те,
  которые записываются данным запросом. При обнаружении нарушения информация о нем
  сохраняется для дальнейшего вывода пользователю, а в запросе очищается множество
  регистров. Таким образом, на один запрос в очереди созадется не больше одного сообщения
  о нарушении, при этом состояние очереди (число запросов) остается правильным.
\item Инструкции, выполняющие обращение к памяти: в очередь помещается информация о
  типе обращения, множестве записываемых регистров, адресе текущей инструкции.
\end{ul}

\subsection{Составление алгоритма проверки слотов задержки}

\todo{...}

\section{Создание программной реализации средства статического анализа}

\todo{...}

\newpage
\phantomsection
\addcontentsline{toc}{section}{СПИСОК ИСТОЧНИКОВ}
\selectlanguage{russian}
\printbibliography[title={СПИСОК ИСТОЧНИКОВ}]

\end{document}
