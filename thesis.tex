\documentclass[a4paper,14pt]{extarticle}
\usepackage{fontspec, unicode-math}
\usepackage[english, russian]{babel}
\setmainfont{Times New Roman}
\setmonofont{CMU Typewriter Text}

\usepackage{enumitem}

% === Formatting ===
% Based on https://github.com/3ap/ifmo-vkr-preamble

\usepackage[top=20mm, bottom=20mm, left=25mm, right=10mm]{geometry}

\usepackage[nodisplayskipstretch]{setspace}
\onehalfspacing

\addto\captionsrussian{
  \renewcommand{\contentsname}{Оглавление}
}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage{titlesec}
\titleformat{\section}[block]{\centering\bfseries\large}{\arabic{section}}{1ex}{\MakeUppercase}
\titleformat{\subsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}}{1ex}{}
\titleformat{\subsubsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}{1ex}{}
\titlespacing*{\section}{0pt}{42pt}{42pt}

% === Bibliography ===

\usepackage[parentracker=true,
  backend=biber,
  language=russian,
  autolang=other,
  sorting=none,
  citestyle=gost-numeric,
  bibstyle=gost-numeric,
]{biblatex}
\addbibresource{thesis.bib}

% === Commands ===

\newcommand{\topic}[2]{\textbf{#1.} #2\newline}

\newenvironment{ul}{\begin{itemize}[noitemsep,topsep=0em]}{\end{itemize}\vspace{0.2mm}}

% === Body ===

\begin{document}

\tableofcontents
\newpage

\section*{ВВЕДЕНИЕ}
\addcontentsline{toc}{section}{ВВЕДЕНИЕ}

\topic{Актуальность темы исследования}{Графические процессоры широко используются
для математических расчетов, в частности, в машинном обучении. Для достижения оптимальной
утилизации аппаратных ресурсов алгоритмы реализуются при помощи ассемблера.
Отсутствие средств верификации ассемблерных программ для ГП затрудняет разработку
и может привести к некорректным результатам.

В работе рассматриваются графические процессоры AMD, которые предоставляют разработчику
на ассемблере доступ к аппаратному набору команд. В связи с этим требуется ручное
разрешение некоторых зависимостей по данным, а также поддержка различных версий программ
для каждого семейства ГП. Статический анализ позволит обнаружить некорректное
поведение программы еще на этапе ее разработки.}

\topic{Степень теоретической разработанности темы}{Статический анализ исполняемых файлов
широко рассмотрен в работах, посвященных информационной безопасности, а именно:
дизассемблированию обфусцированного кода и обнаружению вирусов,
проверке недоверенного кода в плагинах на некорректный доступ к памяти и т.д.\cite{static-analysis-binary}

Существующие средства статического анализа для графических процессоров работают с
высокоуровневыми языками (CUDA, OpenCL) и направлены на обнаружение состояний
гонки (\textit{data races}), при которых несколько потоков записывают
и читают одни и те же данные в памяти без синхронизации, т.е. ошибки, которые
не отслеживаются компилятором.\cite{gpu-static-verification}

Cочетание статического анализа исполняемых файлов и программ для графических
процессоров широко не рассматривается, поскольку разработка ассемблерных программ,
оптимизированных для конкретных ГП, менее распространена и зачастую выполняется
проприетарно.}

\textbf{Цель работы:} (...)

\textbf{Задачи:}
\begin{ul}
\item ?
\end{ul}

\textbf{Практическая значимость:} (...)

\section{Обзор предметной области}

\subsection{Программы для графических процессоров}

Современные графические процессоры реализуют модель выполнения \textit{SIMT} (одиночный поток
команд, множество потоков). Программа разделяется на множество потоков исполнения (\textit{workitems}),
каждый из которых может следовать произвольному пути в программе.

В графических процессорах AMD одна и та же инструкция в программе исполняется одновременно
на наборе из 64 потоков, именуемом \textit{wavefront}. Инструкции делятся на два вида:
векторные и скалярные. Векторные операции применяются к значениям в каждом потоке
за счет использования SIMD АЛУ. Скалярные операции применяются к одному значению на весь набор
потоков.

Ветвление осуществляется двумя способами: изменением счетчика команд скалярными инструкциями
и маскированием потоков векторными инструкциями сравнения. Маскирование заключается в изменении
маски активности (\textit{EXEC}), каждый бит которой соотвествует отдельному потоку.
Для потоков с нулевым битом векторные операции интерпретируются как NOP.

Как и в центральных процессорах, время доступа к памяти в графических ускорителях значительно
превышает время выполнения арифметико-логических инструкций. Для сокращения простоя в современных
ЦП используется внеочередное исполнение, при котором инструкции выполняются не в порядке следования
в программе, а в порядке доступности операндов. В ГП для скрытия задержки используется иной механизм:
при ожидании данных одним набором потоков исполнение переходит к следующему.
% http://developer.amd.com/wordpress/media/2012/10/GCN-Performance-FTW-Stephan-Hodes.ppsx

Тем не менее, количество наборов потоков, между которыми передается управление, ограничено
аппаратными ресурсами, в частности, объемом регистрового файла для хранения состояния каждого
исполняемого набора. В связи с этим операции с памятью в архитектуре ГП AMD асинхронны.
После запроса на чтение или запись программист может вставить несвязанные инструкции,
сократив время простоя АЛУ. Требование готовности данных обозначается специальной
инструкцией \texttt{s\_waitcnt} — <<ожидание значения счетчика>>.

Предусмотрено три счетчика операций:
\begin{ul}
\item \texttt{vmcnt} для векторных операций с глобальной памятью;
\item \texttt{lgkmcnt} для скалярных операций с глобальной памятью и векторных операций с локальной памятью;
\item \texttt{expcnt} для векторных операций записи в общую память.
\end{ul}

После каждой операции с памятью соответствующий счетчик инкрементируется, а по завершении
операции — декрементируется. Операции одного типа завершаются в порядке очереди, что
позволяет ожидать готовности только тех данных, которые необходимы для вычислений в данный
момент. Если же счетчик содержит операции различных типов, или какая-либо из операций
характеризуется внеочередным завершением (скалярный доступ к памяти), то очередность не гарантируется.
В таком случае программист должен ожидать обуления соответствующего счетчика.

При создании ассемблерных шейдеров, программист заинтересован в том, чтобы между запросом к памяти
и ожиданием счетчика было как можно больше несвязанных арифметических операций, а ожидаемое
значение было как можно более точным, поскольку это увеличивает долю полезной работы. В то же время
повышается вероятность совершения ошибки — пропуска необходимой инструкции из-за сложной структуры программы.

Помимо этого, существует ряд зависимостей по данным, не связанных с доступом к памяти,
которые также не отслеживаются графическим процессором из-за особенностей аппаратной реализации.
В таких случаях программист должен вручную обеспечить необходимое количество независимых
инструкций между зависимыми операциями. В официальном руководстве к архитектуре GCN
таких ситуаций определено 16.\cite{vega-isa} Архитектура CDNA, на которой основывается передовой ускоритель
вычислений MI100, добавляет к этому 21 ситуацию, относящуюся к матричным операциям.\cite{cdna-isa}

\subsection{Подходы к анализу программ}

Статический и динамический анализ. Динамический анализ затрудняется тем, что некорректное
поведение может вызвать аппаратную ошибку, восстановление которой потребует перезагрузки
системы и приведет к потере данных для анализа.  % citation needed

Как правило, инструменты статического анализа работают с исходным кодом программ,
поскольку в них сохраняются высокоуровневые конструкции (переменные, циклы, функции).

В ассемблерных программах подобные конструкции реализуются при помощи макросов,
которые не несут в себе полезной для анализа информации (области видимости и т.д.).
Помимо этого, существует несколько трансляторов ассемблерного кода — GAS, CRLX, проприетарные — которые
различаются набором макросов и синтаксисом инструкций.

В связи с этим в качестве исходных данных в работе рассматриваются исполняемые файлы,
формат которых строго определен.

\subsection{Трудности анализа исполняемых программ}

\topic{Извлечение машинного кода}{Запуск вычислительных шейдеров на платформе AMD как правило просходит
в средах исполнения HSA и HIP. Программы хранятся в файлах ELF, которые именуются \textit{code objects (CO)}.
Встречается несколько версий файла с различной структурой программы: так,
в \textit{CO V2} метаданные хранятся как часть исполняемой секции \texttt{.text}, а
в \textit{CO V3} они записываются в отдельную секцию ELF.}

\topic{Отсутствие высокоуровневой информации}{Хотя в исполняемых файлах могут сохранятся отладочные символы
(имена меток и макросов), в анализе они использоваться не должны, поскольку их наличие не гарантируется.
Символы могут быть намеренно удалены для уменьшения размера исполняемого файла;
некоторые трансляторы ассемблерного кода изначально не поддерживают таблицы символов.}

\topic{Дизассемблирование}{Проект LLVM включает в себя официально поддерживаемый дизассемблер
для графических процессоров AMD, который позволяет сопоставить машинный код команды с ее текстовым
представлением. Задача усложняется тем, что исполняемая программа может содержать не только команды,
но и данные. Для правильного дизассемблирования необходимо следовать потоку управления,
т.е. интерпретировать инструкции перехода.}

\topic{Восстановление потока управления}{Помимо статических команд перехода, в которых напрямую
кодируется адрес следующей инструкции, набор инструкций графических процессоров AMD также содержит
команды динамического перехода, в которых адрес следующей инструкции считывается из регистров
общего назначения.}

\selectlanguage{russian}
\printbibliography[title={Список источников}]

\end{document}
