\documentclass[a4paper,14pt]{extarticle}
\usepackage{fontspec, unicode-math}
\usepackage[english, russian]{babel}
\setmainfont{Times New Roman}
\setmonofont{CMU Typewriter Text}

% === Formatting ===
% Based on https://github.com/3ap/ifmo-vkr-preamble

\usepackage[top=20mm, bottom=20mm, left=25mm, right=10mm]{geometry}

\usepackage[nodisplayskipstretch]{setspace}
\onehalfspacing

\addto\captionsrussian{
  \renewcommand{\contentsname}{Оглавление}
}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage{titlesec}
\titleformat{\section}[block]{\centering\bfseries\large}{\arabic{section}}{1ex}{\MakeUppercase}
\titleformat{\subsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}}{1ex}{}
\titleformat{\subsubsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}{1ex}{}
\titlespacing*{\section}{0pt}{42pt}{42pt}

% === Commands ===

\newcommand{\topic}[2]{\textbf{#1.} #2\newline}

% === Body ===

\begin{document}

\tableofcontents
\newpage

\section*{ВВЕДЕНИЕ}
\addcontentsline{toc}{section}{ВВЕДЕНИЕ}

\topic{Актуальность темы исследования}{Графические процессоры широко используются
для математических расчетов, в частности, в машинном обучении. Для достижения оптимальной
утилизации аппаратных ресурсов алгоритмы реализуются при помощи ассемблера.
Отсутствие средств верификации ассемблерных программ для ГП затрудняет разработку
и может привести к некорректным результатам.

В работе рассматриваются графические процессоры AMD, которые предоставляют разработчику
на ассемблере доступ к аппаратному набору команд. В связи с этим требуется ручное
разрешение некоторых зависимостей по данным, а также поддержка различных версий программ
для каждого семейства ГП. Статический анализ позволит обнаружить некорректное
поведение программы еще на этапе ее разработки.}

\topic{Степень теоретической разработанности темы}{Статический анализ исполняемых файлов
широко рассмотрен в работах, посвященных информационной безопасности, а именно:
дизассемблированию обфусцированного кода и обнаружению вирусов,
проверке недоверенного кода в плагинах на некорректный доступ к памяти и т.д.
% https://pdfs.semanticscholar.org/a1e9/688c8513fa90a8fbeccda2e82affe99e1176.pdf

Существующие средства статического анализа для графических процессоров работают с
высокоуровневыми языками (CUDA, OpenCL) и направлены на обнаружение состояний
гонки (\textit{data races}), при которых несколько потоков записывают
и читают одни и те же данные в памяти без синхронизации, т.е. ошибки, которые
не отслеживаются компилятором.
% sci-hub.do/10.1007/978-3-319-08867-9_15

Cочетание статического анализа исполняемых файлов и программ для графических
процессоров широко не рассматривается, поскольку разработка ассемблерных программ,
оптимизированных для конкретных ГП, менее распространена и зачастую выполняется
проприетарно.}

\textbf{Цель работы:} (...)

\textbf{Задачи:}
\begin{itemize}
\item ?
\end{itemize}

\textbf{Практическая значимость:} (...)

\section{Обзор предметной области}

\subsection{Средства анализа программ}

Статический и динамический анализ. Динамический анализ затрудняется тем, что некорректное
поведение может вызвать аппаратную ошибку, восстановление которой потребует перезагрузки
системы и приведет к потере данных для анализа.  % citation needed

Как правило, инструменты статического анализа работают с исходным кодом программ,
поскольку в них сохраняются высокоуровневые конструкции (переменные, циклы, функции).

В ассемблерных программах подобные конструкции реализуются при помощи макросов,
которые не несут в себе полезной для анализа информации (области видимости и т.д.).
Помимо этого, существует несколько трансляторов ассемблерного кода — GAS, CRLX, проприетарные — которые
различаются набором макросов и синтаксисом инструкций.

В связи с этим в качестве исходных данных в работе рассматриваются исполняемые файлы,
формат которых строго определен.

\subsection{Программы для графических процессоров}

SIMT, workitems, wavefronts, workgroups.

Программы для ГП, как правило, обладают более простым потоком
управления, нежели программы для центральных процессоров. В большинстве случаев отсутствуют
динамические вызовы (системные и библиотечные). Сами программы можно рассматривать как
функции без побочных эффектов: одни и те же входные данные приводят к одному и тому же результату.

Аппаратный набор инструкций графических процессоров NVIDIA недоступен для разработчиков.
Вместо этого предоставляется виртуальный набор инструкций PTX, который остается
обратно совместимым между семействами ГП и транслируется драйвером перед выполнением.
% https://docs.nvidia.com/pdf/ptx_isa_7.0.pdf (goals of ptx)

Компания AMD предоставляет доступ к набору инструкций каждого семейства ГП. Таким образом,
программист получает полный контроль над исполнением программ, в том числе становится
ответственным за разрешение зависимостей по данным и управлению путем вставки специальных
инструкций.
% https://developer.amd.com/wp-content/resources/Vega_Shader_ISA_28July2017.pdf
Задача усложняется тем, что ситуации, которые необходимо обрабатывать вручную,
меняются от семейства к семейству ГП и могут быть незадокументированными в официальных документах.
% https://gitlab.freedesktop.org/mesa/mesa/blob/a0c003007515e31c63e18f4a3c8abc86814143bf/src/amd/compiler/README

\subsection{Трудности анализа исполняемых программ}

\topic{Извлечение машинного кода}{Запуск вычислительных шейдеров на платформе AMD как правило просходит
в средах исполнения HSA и HIP. Программы хранятся в файлах ELF, которые именуются \textit{code objects (CO)}.
Встречается несколько версий файла с различной структурой программы: так,
в \textit{CO V2} метаданные хранятся как часть исполняемой секции \texttt{.text}, а
в \textit{CO V3} они записываются в отдельную секцию ELF.}

\topic{Отсутствие высокоуровневой информации}{Хотя в исполняемых файлах могут сохранятся отладочные символы
(имена меток и макросов), в анализе они использоваться не должны, поскольку их наличие не гарантируется.
Символы могут быть намеренно удалены для уменьшения размера исполняемого файла;
некоторые трансляторы ассемблерного кода изначально не поддерживают таблицы символов.}

\topic{Дизассемблирование}{Проект LLVM включает в себя официально поддерживаемый дизассемблер
для графических процессоров AMD, который позволяет сопоставить машинный код команды с ее текстовым
представлением. Задача усложняется тем, что исполняемая программа может содержать не только команды,
но и данные. Для правильного дизассемблирования необходимо следовать потоку управления,
т.е. интерпретировать инструкции перехода.}

\topic{Восстановление потока управления}{Помимо статических команд перехода, в которых напрямую
кодируется адрес следующей инструкции, набор инструкций графических процессоров AMD также содержит
команды динамического перехода, в которых адрес следующей инструкции считывается из регистров
общего назначения.}

\end{document}
