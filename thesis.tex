\documentclass[a4paper,14pt]{extarticle}
\usepackage{fontspec, unicode-math}
\usepackage[english, russian]{babel}
\setmainfont{Times New Roman}
\setmonofont{CMU Typewriter Text}

\usepackage{enumitem}
\usepackage{alltt}

% === WIP ===

\usepackage{xcolor}
\newcommand{\todo}[1]{\textbf{\textcolor{red}{#1}}}

% === Formatting ===
% Based on https://github.com/3ap/ifmo-vkr-preamble

\usepackage[top=20mm, bottom=20mm, left=25mm, right=10mm]{geometry}

\usepackage[nodisplayskipstretch]{setspace}
\onehalfspacing

\addto\captionsrussian{
  \renewcommand{\contentsname}{Оглавление}
}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage{titlesec}
\titleformat{\section}[block]{\centering\bfseries\large}{\arabic{section}}{1ex}{\MakeUppercase}
\titleformat{\subsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}}{1ex}{}
\titleformat{\subsubsection}[block]{\hspace{\parindent}\bfseries\normalsize}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}{1ex}{}
\titlespacing*{\section}{0pt}{42pt}{42pt}

% === Bibliography ===

\usepackage[parentracker=true,
  backend=biber,
  language=russian,
  autolang=other,
  sorting=none,
  citestyle=gost-numeric,
  bibstyle=gost-numeric,
]{biblatex}
\addbibresource{thesis.bib}

\usepackage{xurl}
\usepackage[hidelinks]{hyperref}

% === Commands ===

\newcommand{\topic}[1]{\textbf{#1.}}

\newenvironment{ul}{\begin{itemize}[noitemsep,topsep=0em]}{\end{itemize}\vspace{4mm}}

\newenvironment{ol}{\begin{enumerate}[noitemsep,topsep=0em]}{\end{enumerate}\vspace{4mm}}

\newenvironment{inlineul}{\begin{itemize}[noitemsep,topsep=0em]}{\end{itemize}}

\newenvironment{inlineol}{\begin{enumerate}[noitemsep,topsep=0em]}{\end{enumerate}}

% === Body ===

\begin{document}

\tableofcontents
\newpage

\section*{ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ}
\phantomsection\addcontentsline{toc}{section}{ТЕРМИНЫ И ОПРЕДЕЛЕНИЯ}

\textit{Шейдер} — программа, предназначенная для исполнения на графическом процессоре.

\newpage

\section*{ВВЕДЕНИЕ}
\phantomsection\addcontentsline{toc}{section}{ВВЕДЕНИЕ}

\topic{Актуальность темы исследования} Графические процессоры широко используются
для математических расчетов, в частности, в машинном обучении. Для достижения оптимальной
утилизации аппаратных ресурсов алгоритмы реализуются при помощи ассемблера.
Отсутствие средств верификации ассемблерных программ для ГП затрудняет разработку
и может привести к некорректным результатам.

В работе рассматриваются графические процессоры AMD, которые предоставляют разработчику
на ассемблере доступ к аппаратному набору команд. В связи с этим требуется ручное
разрешение некоторых зависимостей по данным, а также поддержка различных версий программ
для каждого семейства ГП. Статический анализ позволит обнаружить некорректное
поведение программы еще на этапе ее разработки.

\topic{Степень теоретической разработанности темы} Статический анализ исполняемых файлов
широко рассмотрен в работах, посвященных информационной безопасности, а именно:
дизассемблированию обфусцированного кода и обнаружению вирусов,
проверке недоверенного кода в плагинах на некорректный доступ к памяти и т.д.\cite{static-analysis-binary}

Существующие средства статического анализа для графических процессоров работают с
высокоуровневыми языками (CUDA, OpenCL) и направлены на обнаружение состояний
гонки (\textit{data races}), при которых несколько потоков записывают
и читают одни и те же данные в памяти без синхронизации, т.е. ошибки, которые
не отслеживаются компилятором\cite{gpu-static-verification}.

Cочетание статического анализа исполняемых файлов и программ для графических
процессоров широко не рассматривается, поскольку разработка ассемблерных программ,
оптимизированных для конкретных ГП, менее распространена и зачастую выполняется
проприетарно.

\textbf{Цель работы:} (...)

\textbf{Задачи:}
\begin{ul}
\item ?
\end{ul}

\textbf{Практическая значимость:} (...)

\section{Обзор предметной области}

\subsection{Неспециализированные вычисления на графических процессорах}

Графические процессоры широко применяются для неспециализированных вычислений —
\textit{general-purpose computing on graphics processing units, GPGPU}.
Особый интерес представляют математические расчеты, используемые в
\textit{сверточных нейронных сетях} — методе машинного обучения, в основе которого
лежат матричные операции свертки, субдискретизации (\textit{pooling}) и т.п.
Производительность графических ускорителей в выполнении подобных операций
значительно превышает производительность центральных процессоров.

Для исполнения неспециализированных вычислений требуются специальные платформы,
которые выполняют несколько задач:
\begin{ul}
\item Преобразование исходных текстов на определенном языке программирования
  в исполняемый файл, содержащий инструкции для графического процессора и метаданные о программе.
\item Предоставление библиотек математических примитивов (BLAS, FFT)
  для использования в вычислительных шейдерах.
\item Предоставление набора интерфейсов для запуска программ на ГП, перемещения данных между
  оперативной памятью и выделенной памятью ускорителя, выполнения других операций.
\item Обеспечение взаимодействия между драйвером ускорителя и пользовательской программой,
  использующей интерфейсы платформы.
\end{ul}

Компания NVIDIA предоставляет для своих ускорителей платформу \textit{CUDA}. Прямым аналогом
со стороны AMD является \textit{ROCm}. Вычислительные шейдеры могут составляться как
на высокоуровневых языках (C++11, OpenCL), так и на ассемблере. Платформа доступна
только на операционной системе Linux.

\subsection{Исполнение программ на графических процессорах}

Графические процессоры достигают высокой производительности в математических операциях
за счет реализации модели выполнения \textit{SIMT} (одиночный поток команд, множество потоков).
Программа разделяется на множество потоков исполнения (\textit{workitems}),
каждый из которых может следовать произвольному пути в программе.

В графических процессорах AMD одна и та же инструкция в программе исполняется одновременно
на наборе из 64 потоков, именуемом \textit{wavefront}. Инструкции делятся на два вида:
векторные и скалярные. Векторные операции применяются к значениям в каждом потоке
за счет использования SIMD АЛУ. Скалярные операции применяются к одному значению на весь набор
потоков.

Ветвление осуществляется двумя способами: изменением счетчика команд скалярными инструкциями
и маскированием потоков векторными инструкциями сравнения. Маскирование заключается в изменении
маски активности (\textit{EXEC}), каждый бит которой соотвествует отдельному потоку.
Для потоков с нулевым битом векторные операции интерпретируются как NOP.

\subsection{Специальные требования к программам, исполняемым на графических процессорах}

\todo{...}

\subsubsection{Ожидание готовности данных при запросах к памяти}

Как и в центральных процессорах, время доступа к памяти в графических ускорителях
значительно превышает время выполнения арифметико-логических инструкций.
Для сокращения простоя в современных ЦП используется внеочередное исполнение, при котором
инструкции выполняются не в порядке следования в программе, а в порядке доступности операндов.
В ГП для скрытия задержки используется иной механизм: при ожидании данных одним набором
потоков исполнение переходит к следующему.
% http://developer.amd.com/wordpress/media/2012/10/GCN-Performance-FTW-Stephan-Hodes.ppsx

Тем не менее, количество наборов потоков, между которыми передается управление, ограничено
аппаратными ресурсами — в частности, объемом регистрового файла для хранения состояния каждого
исполняемого набора. В связи с этим операции с памятью в архитектуре ГП AMD асинхронны.
После запроса на чтение или запись программист может вставить несвязанные инструкции,
сократив время простоя АЛУ. Требование готовности данных обозначается специальной
инструкцией \texttt{s\_waitcnt}, <<ожидание значения счетчика>>.

Предусмотрено три счетчика операций:
\begin{ul}
\item \texttt{vmcnt} для векторных операций с глобальной памятью;
\item \texttt{lgkmcnt} для скалярных операций с глобальной памятью и векторных операций с локальной памятью;
\item \texttt{expcnt} для векторных операций записи в общую память.
\end{ul}

После каждой операции с памятью соответствующий счетчик инкрементируется, а по завершении
операции — декрементируется. Операции одного типа завершаются в порядке очереди, что
позволяет ожидать готовности только тех данных, которые необходимы для вычислений в данный
момент. Если же счетчик содержит операции различных типов, или какая-либо из операций
характеризуется внеочередным завершением (скалярный доступ к памяти), то очередность не гарантируется.
В таком случае программист должен ожидать обуления соответствующего счетчика.

\subsubsection{Вставка слотов задержки для инструкций, зависимых по данным}

Существует также ряд зависимостей по данным, не связанных с доступом к памяти,
которые не отслеживаются графическим процессором из-за особенностей аппаратной реализации.
В таких случаях программист должен вручную обеспечить необходимое количество независимых
инструкций между зависимыми операциями. В официальном руководстве к архитектуре GCN
таких ситуаций определено 16\cite{vega-isa}. Архитектура CDNA, на которой основывается передовой ускоритель
вычислений MI100, добавляет к этому 21 ситуацию, относящуюся к матричным операциям\cite{cdna-isa}.

\subsection{Разрешение зависимостей при компиляции шейдеров}

При использовании высокоуровневых языков программисту не требуется следить за соблюдением
описанных требований к шейдерам; эту задачу берет на себя компилятор.
Перед изучением используемых алгоритмов разрешения зависимостей рассмотрим общий
принцип работы современных компиляторов.

Поддержка различных языков программирования и целевых платформ осуществляется
путем выделения независимых фаз компиляции, которые реализуются отдельными модулями.
Выделяют три основных модуля\cite[Глава~1]{compilers}:

\begin{ul}
\item \textit{фронтэнд} (\textit{frontend}), отвечающий за трансляцию исходного текста программы в
  \textit{промежуточное представление};
\item \textit{оптимизатор} (\textit{optimizer}), выполняющий различные преобразования над промежуточным
  представлением, которые направлены на сокращение времени исполнения,
  уменьшение размера программы и т.д.;
\item \textit{бэкэнд} (\textit{backend}), преобразующий промежуточное представление в машинный код.
\end{ul}

Помимо промежуточного представления программы, которое передается между фазами,
модуль может использовать внутренние представления, необходимые для выполнения его функций.
Например, при чтении исходного кода программы фронтэнд создает синтаксические деревья,
а при генерации машинного кода бэкэнд работает с различными графами, моделирующими поведение
программы.

Интересующая нас задача вставки инструкций \texttt{s\_waitcnt} и \texttt{s\_nop} входит
в диспетчеризацию инструкций, которая производится бэкэндом над представлением программы
в виде \textit{управляющего графа} (\textit{control flow graph}).

Управляющий граф\cite{cfg-allen}\cite{cfg-ru} представляет собой ориентированный граф, вершинами которого
выступают \textit{базовые блоки} (\textit{basic blocks}) — последовательности инструкций,
не содержащие переходов в другие места программы, за исключением последней
инструкции в блоке, \textit{точки выхода}. Ребра отражают переходы в программе.
В задачах анализа важны следующие взаимосвязи вершин:
\begin{inlineul}
\item \textit{потомок вершины $p$} (\textit{successor of $p$}) — такая вершина $q$,
  для которой в орграфе существует путь из $p$ в $q$;
\item \textit{предок вершины $p$} (\textit{predecessor of $p$}) — такая вершина $q$,
  для которой в орграфе существует путь из $q$ в $p$.
\end{inlineul}
Стоит отметить, что одна и та же вершина $q$ может быть как потомком, так и предком вершины $p$,
что отражает циклическую конструкцию в программе.

Основным методом решения задач статического анализа являются итеративный подход\cite[Глава~8]{compilers}.
Каждой вершине присваивается изначальное состояние. В процессе обхода графа к каждой вершине
применяется функция, преобразующая ее текущее состояние в новое. Полученное состояние
соединяется с состоянием последующих вершин в направлении обхода, образуя их новые состояния.
Обход продолжается до тех пор, пока не будет достигнута неподвижная точка (\textit{fixed point}), т.е.
пока состояния вершин не перестанут изменяться. Конечность алгоритма анализа может гарантироваться
при условии, что домен состояний является конечным множеством, а изменение состояний происходит монотонно.

Порядок обхода графа выбирается в зависимости от решаемой задачи:
\begin{ul}
\item Анализ прямого потока данных (\textit{forward dataflow}), к которому относится отслеживание обращений
  к памяти, производится при помощи прямого обхода в глубину (\textit{preorder}; посещается блок, затем его потомки) или RPO-обхода (\textit{reverse postorder}; блок посещается после всех предков, за исключением предков, которые связаны с блоком обратными ребрами).

\item Анализ обратного потока данных (\textit{backward dataflow}), к которому относится проверка вставки
слотов задержки перед использованием зависимых данных, производится при помощи обратного обхода
(\textit{postorder}; посещается блок, затем его предки).
\end{ul}

В платформе ROCm для всех поддерживаемых высокоуровневых языков программирования (С++, OpenCL)
используется единый компилятор шейдеров — \textit{Clang}, часть проекта LLVM.
Компилятор обладает модульным смотрением, описаным выше.

За генерацию машинного кода для графических процессоров AMD отвечает бэкэнд AMDGPU.
Рассмотрим подробнее его работу в LLVM версии 12\cite{llvm-12}.

\subsubsection{Обработка запросов к памяти в компиляторе LLVM}

Модуль вставки инструкций \texttt{s\_waitcnt} расположен в исходном файле
\url{llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp}.
Используется итеративный алгоритм анализа прямого потока данных.
Обход управляющего графа осуществляется в RPO-порядке.

Каждому из блоков присваивается объект \texttt{WaitcntBrackets}, отслеживающий:
\begin{ul}
\item число всех обращений к памяти для каждого из счетчиков операций
  (\texttt{vmcnt}, \texttt{lgkmcnt}, \texttt{expcnt}) — $ScoreUb$;
\item число завершенных операций для каждого из счетчиков (согласно
  вставленным инструкциям \texttt{s\_waitcnt}) — $ScoreLb$;
\item номер последней операции, использующей регистр, для всех регистров
  в программе (отсутствию операций соответствует значение $0$) — $VgprScores$, $SgprScores$.
\end{ul}

Функция обновления состояния блока посещает каждую инструкцию в блоке в порядке
исполнения. При этом выполняется следующая последовательность действий:
\begin{ol}
\item Проверяются случаи, в которых необходимо добавить выражение ожидания:
  \begin{ol}
  \item при выходе из функции (\texttt{s\_setpc\_b64}) ожидаются все операции;
  \item если операнд инструкции является скалярным регистром $s$, который используется в
    незавершенной операции, т.е. выполняется\newline$SgprScores[s] > ScoreLb[lgkmcnt]$:
    \begin{inlineol}
    \item при наличии незавершенных операций \texttt{flat} согласно архитектуре набора
      команд\cite[Глава~9.2.2]{vega-isa} вставляется \texttt{s\_waitcnt 0};
    \item иначе вставляется \texttt{s\_waitcnt lgkmcnt(0)}, поскольку скалярные операции с памятью
      выполняются вне очереди;
    \end{inlineol}
  \item если операнд инструкции является векторным регистром $v$, который используется в
    незавершенной операции, т.е. выполняется\newline$VgprScores[vmcnt][v] > ScoreLb[vmcnt]$\newline
    или $VgprScores[lgkmcnt][v] > ScoreLb[lgkmcnt]$:
    \begin{inlineol}
    \item при наличии незавершенных операций \texttt{flat} согласно архитектуре набора
      команд вставляется \texttt{s\_waitcnt 0};
    \item если операция входит в счетчик \texttt{vmcnt}, то вставляется \texttt{s\_waitcnt vmcnt(w)},
      где $w = ScoreUb[vmcnt] - VgprScores[vmcnt][v]$;
    \item если операция входит в счетчик \texttt{lgkmcnt} и имеет тот же тип, что и все
      незавершенные операции в счетчике, то вставляется \texttt{s\_waitcnt vmcnt(w)},
      где $w = ScoreUb[lgkmcnt] - VgprScores[lgkmcnt][v]$;
    \item иначе вставляется \texttt{s\_waitcnt lgkmcnt(0)}, поскольку скалярные операции с памятью
      выполняются вне очереди.
    \end{inlineol}
  \end{ol}
\item Если необходимо добавить выражение ожидание:
  \begin{ol}
  \item при наличии в блоке предшествующей инструкции \texttt{s\_waitcnt} выражение объединяется
    с предшествующей инструкцией, иначе в блок вставляется новая инструкция \texttt{s\_waitcnt};
  \item обновляется число завершенных операций ($ScoreLb$) для счетчиков,
    которые входят в выражение ожидания.
  \end{ol}
\item Если рассматриваемая инструкция является обращением к памяти,
  число обращений к памяти ($ScoreUb$) инкрементируется, и полученное значение
  присваивается номеру операции регистра назначения ($VgprScores$ или\newline$SgprScores$).
\end{ol}

Функция соединения, которая обновляет состояния всех потомков рассматриваемого блока,
подсчитывает незавершенные операции в исходном и новом состоянии, и обновляет
счетчики согласно наибольшим значениям, т.е. изменение состояний происходит монотонно.

Исследование принципа работы используемого алгоритма позволяет заключить, что он обладает
следующими ограничениями:
\begin{ul}
\item в некоторых случаях (например, перед возвратом из функции) вставляются слишком
  строгие ожидания, что может привести к ненужному простою АЛУ;
\item отслеживается только числовое значение счетчиков — если существующей инструкции
  \texttt{s\_waitcnt} недостаточно, алгоритм не позволяет определить, какая команда
  совершила неучтенное обращение к памяти.
\end{ul}

\subsubsection{Вставка слотов задержки в компиляторе LLVM}

Модуль добавления инструкций \texttt{s\_nop} для разрешения зависимостей
расположен в исходном файле \url{llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp}.

Используется итеративный алгоритм анализа \textit{обратного} потока данных.

\todo{1. Алгоритмы не отслеживают источник проблемы, а нацелены на ее решение самым простым образом;
2. Ассемблерные вставки верифицируются лишь частично \url{https://github.com/llvm/llvm-project/blob/release/12.x/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp\#L778}}

\subsection{Ручное составление ассемблерных шейдеров}

\todo{rewrite: compare to automated approaches}

При создании ассемблерных шейдеров программист заинтересован в том,
чтобы между запросом к памяти и ожиданием счетчика было как можно больше несвязанных
арифметических операций, а ожидаемое значение было как можно более точным, поскольку
это увеличивает долю полезной работы. В то же время повышается вероятность совершения
ошибки — пропуска необходимой инструкции из-за сложной структуры программы.

\todo{outdated}

Статический и динамический анализ. Динамический анализ затрудняется тем, что некорректное
поведение может вызвать аппаратную ошибку, восстановление которой потребует перезагрузки
системы и приведет к потере данных для анализа.  % citation needed

Как правило, инструменты статического анализа работают с исходным кодом программ,
поскольку в них сохраняются высокоуровневые конструкции (переменные, циклы, функции).

В ассемблерных программах подобные конструкции реализуются при помощи макросов,
которые не несут в себе полезной для анализа информации, такой как области видимости и пр.
Помимо этого, существует несколько трансляторов ассемблерного кода — GAS, CRLX, проприетарные — которые
различаются набором макросов и синтаксисом инструкций.

В связи с этим в качестве исходных данных в работе рассматриваются исполняемые файлы,
формат которых строго определен.

\subsection{Обоснование применимости статического анализа}

\todo{Разрешение зависимостей уже существует для высокоуровневых языков. Возможно использование алгоритмов, направленных на отслеживание источников проблем. Различные трансляторы ассемблерного кода, необходимо рассматривать исполняемые файлы. Необходимо восстановить CFG.}

\section{Разработка подхода к статическому анализу шейдеров}

\subsection{Постановка задач, решаемых статическим анализом}

В ходе исследования предметной области были выделены две области, в которых ошибку программиста
на ассемблере может быть сложно диагностировать во время исполнения, но можно полностью
предотвратить, внедря статическую верификацию программу:
\begin{ol}
\item \textbf{Вставка слотов задержки (\texttt{s\_nop})}. При нехватке несвязанных инструкций между операциями, которые зависят по данным, необходимо сформировать предупреждение, которое указывает на
на зависимые инструкции, а также содержит количество недостающих слотов задержки.
\item \textbf{Вставка инструкций ожидания (\texttt{s\_waitcnt})}. При обращении к регистрам, содержание которых читается из памяти, без ожидания соответствующего счетчика, необходимо сформировать предупреждение, которое указывает на инструкцию, читающую регистр, и инструкцию, использующую регистр, а также показывает состояние очереди запросов.
\end{ol}

Разрабатываемый подход к анализу программы должен удовлетворять следующим требованиям:

\begin{ul}
\item входными данными выступают исполняемые (объектные) файлы, поскольку представление исходного текста программы может существенно различаться в зависимости от используемого ассемблера;
\item \todo{восстановление управляющего графа?}
\end{ul}

\subsection{Выделение этапов статического анализа}

Для удовлетворения поставленных требований были выделены следующие этапы работы системы:\\

\topic{Извлечение машинного кода и метаданных} Запуск вычислительных шейдеров на платформе AMD
как правило просходит в средах исполнения HSA и HIP. Программы хранятся в файлах ELF,
которые именуются \textit{code objects (CO)}.
Встречается несколько версий файла с различной структурой программы: так,
в \textit{CO V2} метаданные хранятся как часть исполняемой секции \texttt{.text}, а
в \textit{CO V3} они записываются в секцию \texttt{.rodata}.

Хотя в исполняемых файлах могут сохранятся отладочные символы
(имена меток и макросов), в анализе они использоваться не должны, поскольку их наличие не гарантируется.
Символы могут быть намеренно удалены для уменьшения размера исполняемого файла;
некоторые трансляторы ассемблерного кода изначально не поддерживают таблицы символов.

\topic{Дизассемблирование} Преобразование двоичного кода инструкции в ее текстовое представление
требует построения таблиц кодов операций и реализации логики декодирования операндов.
Задача осложняется следующими особенностями архитектуры команд графических процессоров AMD:
\begin{ul}
\item общее число инструкций превышает несколько сотен \todo{ct};
\item размер машинных инструкций варьируется, поэтому для правильного дизассемблирования необходимо
  учесть все существующие инструкции, даже если при анализе достаточно рассмотрения лишь части операций;
\item кодирование машинных инструкций раличается между семействами графических процессоров.
\end{ul}

Проект LLVM содержит официально поддерживаемый дизассемблер, использование которого позволяет
преодолеть обозначенные трудности.

\topic{Восстановление потока управления} Помимо статических команд перехода, в которых напрямую
кодируется адрес следующей инструкции, набор инструкций графических процессоров AMD также содержит
команды динамического перехода, в которых адрес следующей инструкции считывается из регистров
общего назначения.

\todo{...}

\subsection{Составление алгоритма проверки инструкций ожиданий}

\todo{...}

\subsection{Составление алгоритма проверки слотов задержки}

\todo{...}

\section{Создание программной реализации средства статического анализа}

\todo{...}

\newpage
\phantomsection
\addcontentsline{toc}{section}{СПИСОК ИСТОЧНИКОВ}
\selectlanguage{russian}
\printbibliography[title={СПИСОК ИСТОЧНИКОВ}]

\end{document}
